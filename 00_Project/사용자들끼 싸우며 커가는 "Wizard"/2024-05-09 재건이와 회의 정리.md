이 회의의 목적은 클라이언트와 백엔드 통신을 어떻게 진행할지 이야기 하는 것이다.


### 회의의 흐름 

1. Entity Component System 이용하자 
	1. 왜? 게임의 구성요소를 정확히 명시하여 클라와 서버가 소통할 때 말이 통하게 하기 위해서
	2. 그러나 Entity Component System 을 제대로 공부하지 못한 뒤 회의의 참여하여 이 System을 적용하지 말고 다른 방법으로 하기로 결정함 

2.  현재 있는 구성요소를 가지고 나올 수 있는 모든경우의 수를 명세하자 
	1. 각각의 기능들을 명세하려고 하려고 했는데
		1. 재건이와 나는 서버와 클라 통신 방식에 대해 오해가 있었음 그래서 해결함
			1. 결론적으로 "클라이언트 그림만 그린다. 모니터의 역활을 하고 서버가 진짜 로직처리 역활을 하게 된다." 
-> 그리고 명세 시작함

### 처음에 사용자가 우리 게임에 접속했을 때 
![[IMG_0514.png]]


### 사용자가 W, A, S, D를 움직였을 때 
W, A, S, D Event는 socket.io의 "movement" Evnet로 보낼 예정이고
각각 다음과 같은 template에 보낼 예정이다.  W는 up, A는 Left, S는 Down, D는 right로 
```json
{
	"direction": "~"
}
```


### 서버의 구성요소 정보를 클라이언트들에게 broadcast 해줄 때 
이건 아직 명세를 하지 못함..

#### 우진이가 적어준 것 
Player와 fire_obj의 상호작용
1. Plyaer에 있는 fire_obj 중 하나를 발사
2. 다른 player가 발사한 fire_obj에 피격당했을 경우 fire_obj의 데미지 만큼 player의 hp 감소 

player와 rune의 상호작용
1. fire_obj의 데미지 만큼 Rune의 hp 감소
		rune이 fire_obj에 피격되면
2. Rune 타격을 성공한 fire_obj 삭제 (해당되는 것만)
3. player가 일정레벨에 도달했을 때 fire_obj의 종류 변경
4. player 타격에 성공한 fire_obj 삭제 (해당되는 것만)


지금 와서 생각해보니 웹에서 클라이언트와 서버는 요청과 응답의 관계라면
게임서버와 클라이언트는 데이터 전송과 데이터 동기화의 관계인 것 같다.